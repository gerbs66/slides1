<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
    <style>
      .reveal .hljs table {
          width: 100%;
      }

      .code-block {
        border-radius: 1rem;
      }

      .slide-container {
        display: flex;
        gap: 1rem;

        align-items: center;
      }

      .scene {
        width: 50%;
      }

      section .code-wrapper {
        flex-grow: 1;
        width: 50%;
      }

      p {
        color: black;
      }

      .container {
        border-radius: 1rem;

        font-size: 1.5rem;
        line-height: 1.5rem;
        background: white;
        overflow: hidden;
      }
    </style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

         <section id="section3">
          <h3>light-dark()</h3>
          <div class="slide-container">
            <!-- Visible code block -->
            <pre>
              <code class="code-block hljs" data-trim contenteditable="true" data-line-numbers="3,8-10">
              <style>
                .container {
                }
                body {
                  color: CanvasText;
                  background-color: Canvas;
                }
              </style>
              </code>
            </pre>
        
            <!-- Hidden code block -->
            <script type="text/template" class="hidden-code-block">
              <div class="container">
                <p class="content">I am sentence</p>
                <p class="content">Lorem Ipsum</p>
              </div>
            </script>
        
            <!-- Data-edit container -->
            <div class="scene" data-edit></div>
          </div>

          <div class="slide-container">
            <!-- Visible code block -->
            <pre>
              <code class="code-block hljs" data-trim contenteditable="true" data-line-numbers="3,8-10">
              <style>
                :root {
                  &:has(input[name="color-scheme"][value="light dark"]:checked) {
                    color-scheme: light dark;
                  }
                  &:has(input[name="color-scheme"][value="light"]:checked) {
                    color-scheme: light;
                  }
                  &:has(input[name="color-scheme"][value="dark"]:checked) {
                    color-scheme: dark;
                  }
                }
                .container {
                  color: light-dark(#333b3c, #efefec);
                  background-color: light-dark(#efedea, #223a2c);    
                }
              </style>
              </code>
            </pre>
        
            <!-- Hidden code block -->
            <script type="text/template" class="hidden-code-block">
              <div class="container">
                <div class="row gap">
                  <label><input name="color-scheme" type="radio" value="light dark" checked>light dark</label>
                  <label><input name="color-scheme" type="radio" value="light">light</label>
                  <label><input name="color-scheme" type="radio" value="dark"> dark</label>
                </div>
              </div>
            </script>
        
            <!-- Data-edit container -->
            <div class="scene" data-edit></div>
          </div>
        </section>

        <section id="section1">
          <h3>Centering a DIV WITH BLUE</h3>
          <div class="slide-container">
            <!-- Visible code block -->
            <pre>
              <code class="code-block hljs" data-trim contenteditable="true" data-line-numbers="3,8-10">
              <style>
                .container {
                  align-content: center;
                }
              </style>
              </code>
            </pre>
        
            <!-- Hidden code block -->
            <script type="text/template" class="hidden-code-block">
              <div class="container">
                <p class="content">I am sentence</p>
                <p class="content">Lorem Ipsum</p>
              </div>
            </script>
        
            <!-- Data-edit container -->
            <div class="scene" data-edit></div>
          </div>
        </section>

        <section id="section2">
          <h3>Centering a DIV 2</h3>
          <div class="slide-container">
            <!-- Visible code block -->
            <pre>
              <code class="code-block hljs" data-trim contenteditable="true" data-line-numbers="3,8-10">
              <style>
                .container {
                  align-content: center;
                }
                .box {
                  width: 50px;
                  height: 50px;
                  background: salmon;
                }
              </style>
              </code>
            </pre>
        
            <!-- Hidden code block -->
            <script type="text/template" class="hidden-code-block">
              <div class="container">
                <p class="content">I am sentence</p>
                <p class="content">Lorem Ipsum</p>
              </div>
            </script>
        
            <!-- Data-edit container -->
            <div class="scene" data-edit></div>
          </div>
        </section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script type="module">
			import Editor from './plugin/editor/editor.esm.js';

      /**
       * Given raw CSS text and a scope selector (e.g. '#section1'),
       * this function prefixes each selector with the scope.
       *
       * Note: This is a simplistic approach that assumes:
       * - CSS blocks are in a <style> tag without nested rules.
       * - Selectors do not include edge-cases like commas in strings.
       *
       * You might need a more robust parser for production use.
       */
       function scopeCSS(cssText, scope) {
        // This regex finds selectors and the block following them.
        // Explanation:
        // - ([^{}]+?) matches one or more characters (non-greedily) that aren't { or } (the selectors).
        // - \s*\{ matches the opening brace (with possible whitespace)
        // - ([^}]*?) matches the property block until the closing brace.
        // - \} matches the closing brace.
        const cssRuleRegex = /([^{}]+?)\s*\{([^}]*?)\}/g;

        return cssText.replace(cssRuleRegex, (match, selectors, declarations) => {
          // Process each selector in the comma-separated list
          const scopedSelectors = selectors
            .split(',')
            .map(sel => {
              let trimmed = sel.trim();
              // Skip if the selector already starts with the scope
              if (trimmed.indexOf(scope) === 0) {
                return trimmed;
              }
              // Also, if the selector starts with an at-rule (e.g. @keyframes, @media) or is a percentage value, skip prefixing.
              if (trimmed.startsWith('@') || trimmed.match(/^[\d\.%]+$/)) {
                return trimmed;
              }
              return scope + ' ' + trimmed;
            })
            .join(', ');
          return scopedSelectors + ' {' + declarations + '}';
        });
      }


			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
        highlight: {
          highlightOnLoad: false, // Disable automatic highlighting
        },
				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, Editor ]
			});

			Reveal.on('slidechanged', (event) => {
				if(event.currentSlide.dataset.execute) {

					console.log('going to eval', event.currentSlide.dataset.execute);
					let result = eval(event.currentSlide.dataset.execute);
					let $result = event.currentSlide.querySelector('p.result');
					$result.innerHTML = result;
				}
			});

			Reveal.on('ready', () => {
        const slideContainers = document.querySelectorAll('.slide-container');

        slideContainers.forEach((container, index) => {
          // If the container doesn't have an id, assign one:
          if (!container.id) {
            container.id = 'slide-container-' + (index + 1);
          }
          // Use the container's id as the scope (e.g., "#slide-container-1")
          const containerScope = `#${container.id}`;

          const codeBlock = container.querySelector('.code-block');
          const hiddenCodeBlock = container.querySelector('.hidden-code-block');
          const dataEditDiv = container.querySelector('[data-edit]');

          if (codeBlock && dataEditDiv) {
            // Make sure raw text is stored for caret work as discussed earlier
            codeBlock.dataset.rawContent = codeBlock.innerText;

            const updateDataEdit = () => {
              const visibleContent = codeBlock.dataset.rawContent || codeBlock.innerText;
              const hiddenContent = hiddenCodeBlock ? hiddenCodeBlock.textContent : "";
              let combinedContent = visibleContent + "\n" + hiddenContent;

              // Process <style> tags for scoping using the containerScope variable
              combinedContent = combinedContent.replace(/<style>([\s\S]*?)<\/style>/gi, (match, cssContent) => {
                const scopedCSS = scopeCSS(cssContent, containerScope);
                return `<style>${scopedCSS}</style>`;
              });

              dataEditDiv.innerHTML = combinedContent;
            };

            // Initial update
            updateDataEdit();

            // Apply initial syntax highlighting
						const highlight = Reveal.getPlugin('highlight');
						highlight.highlightBlock(codeBlock);

            // Update raw content when the code block changes
            codeBlock.addEventListener('input', () => {
              codeBlock.dataset.rawContent = codeBlock.innerText;
              updateDataEdit();
            });
          }
        });

        function getCaretCharacterOffsetWithin(element) {
          const selection = window.getSelection();
          let caretOffset = 0;
          if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(range.startContainer, range.startOffset);
            // Instead of using toString() on the DOM, use the stored raw content.
            // This assumes that codeBlock.dataset.rawContent is up to date.
            caretOffset = preCaretRange.toString().length;
          }
          return caretOffset;
        }

        function setCaretAtCharacterOffset(element, offset) {
          const selection = window.getSelection();
          const range = document.createRange();
          let charCount = 0, found = false;

          // A helper function that traverses only text nodes
          function traverseNodes(node) {
            if (node.nodeType === Node.TEXT_NODE) {
              const nextCharCount = charCount + node.length;
              if (!found && offset >= charCount && offset <= nextCharCount) {
                range.setStart(node, offset - charCount);
                range.collapse(true);
                found = true;
              }
              charCount = nextCharCount;
            } else {
              for (let i = 0; i < node.childNodes.length; i++) {
                traverseNodes(node.childNodes[i]);
                if (found) break;
              }
            }
          }
          traverseNodes(element);
          selection.removeAllRanges();
          selection.addRange(range);
        }
			});
		</script>
	</body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Power Hour - The Latest in CSS and Web UI</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/white.css" />
    <script
      type="module"
      src="./node_modules/baseline-status/baseline-status.min.js"
    ></script>

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/atom-one-light.css" />
    <style>
      section > h2,
      section > h3 {
        text-align: left;
        display: inline-block;
        position: relative;

        &::before {
          content: "";
          position: absolute;
          background-color: blue;
          transform: skewX(-30deg);
        }
      }

      section > h2 {
        font-size: 4rem !important;

        &::before {
          top: -20px; /* Adjusted for larger font size */
          left: -40px; /* Shifted to match proportions */
          width: 20px; /* Increased for better balance */
          height: 80px; /* Scaled up with font size */
        }
      }

      section > h3 {
        font-size: 2.5rem !important;

        &::before {
          top: -10px;
          left: -25px;
          width: 12px;
          height: 50px;
        }
      }

      .reveal {
        .hljs table {
          width: 100%;
        }

        .slides {
          text-align: left;
        }

        h2,
        h3 {
          text-transform: initial;
        }

        .code-wrapper {
          border-radius: 1rem;
          resize: both;
          overflow: hidden;
          code {
            box-sizing: border-box;
            border-radius: 1rem;
          }
        }

        p {
          margin: 0;
          color: black;
        }
      }

      baseline-status {
        text-align: left;
        font-size: 12px;
      }

      li {
        font-size: 1.5rem;
      }

      section {
        padding: 0 2rem;
        box-sizing: border-box;
        .code-wrapper {
          flex-grow: 1;
          width: 60%;
          margin: 0;
        }
        .fifty-fifty {
          width: 50%;
        }

        .forty-sixty {
          width: 40%;
        }
      }

      .code-block {
        font-size: 0.8rem;
        line-height: 1rem;
        border-radius: 1rem;
      }

      .slide-container {
        display: flex;
        gap: 1rem;

        align-items: stretch;
        margin-bottom: 1rem;

        &.column {
          flex-direction: column;
        }
      }

      .scene {
        flex-grow: 1;
        width: 50%;
      }

      .container {
        border-radius: 1rem;

        font-size: 1.5rem;
        line-height: 1.5rem;
        background: white;
        overflow: hidden;
        height: 100%;
        align-content: center;
      }

      .baseline-container {
        width: 100%;
        display: flex;
        justify-content: center;
        margin-bottom: 1.5rem;
      }

      .reveal img {
        max-width: none;
        max-height: none;
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-external="slides/introduction.html"></section>
        <section data-external="slides/lightDark.html"></section>
        <section data-external="slides/popover.html"></section>
        <section data-external="slides/startingStyle.html"></section>
        <section data-external="slides/individualTransform.html"></section>
        <section data-external="slides/subgrid.html"></section>
        <section data-external="slides/contentVisibility.html"></section>
        <section data-external="slides/containerQueries.html"></section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <!-- <script src="plugin/external/external.js"></script> -->
    <script type="module">
      import Editor from "./plugin/editor/editor.esm.js";
      import External from "./plugin/external/external.js";

      function wrapRootInScope(rootBlock, scope) {
        const rootContentRegex = /:root\s*\{([\s\S]*)\}\s*$/;
        const match = rootBlock.match(rootContentRegex);
        if (match) {
          let innerCSS = match[1].trim();
          const scopeRegex = new RegExp(scope + "\\s*", "g");
          innerCSS = innerCSS.replace(scopeRegex, "");
          const wrappedInner = scope + " {\n" + innerCSS + "\n}";
          return ":root {\n" + wrappedInner + "\n}\n";
        }
        return rootBlock;
      }

      function extractRootBlock(cssText) {
        const rootIndex = cssText.indexOf(":root");
        if (rootIndex === -1) {
          return { rootBlock: "", cssWithoutRoot: cssText };
        }

        const startBrace = cssText.indexOf("{", rootIndex);
        if (startBrace === -1) {
          return { rootBlock: "", cssWithoutRoot: cssText };
        }

        let count = 1;
        let endBrace = startBrace + 1;
        while (endBrace < cssText.length && count > 0) {
          if (cssText[endBrace] === "{") {
            count++;
          } else if (cssText[endBrace] === "}") {
            count--;
          }
          endBrace++;
        }

        const rootBlock = cssText.substring(rootIndex, endBrace);
        const cssWithoutRoot =
          cssText.slice(0, rootIndex) + cssText.slice(endBrace);
        return { rootBlock, cssWithoutRoot };
      }

      function scopeCSSGood(cssText, scope) {
        const cssRuleRegex = /([^{}]+?)\s*\{([^}]*?)\}/g;
        return cssText.replace(
          cssRuleRegex,
          (match, selectors, declarations) => {
            // console.log('------------------------------------');
            // console.log('match: ', match)
            // console.log('selectors: ', selectors)
            const scopedSelectors = selectors
              .split(",")
              .map((sel) => {
                let trimmed = sel.trim();
                console.log("scope: ", scope, " trimmerD: ", trimmed);
                if (trimmed.startsWith("@") || /^[\d\.%]+$/.test(trimmed)) {
                  return trimmed;
                }
                return scope + " " + trimmed;
              })
              .join(", ");

            // console.log('scopedSelectors: ', scopedSelectors);
            // console.log('declarations: ', declarations);
            // console.log('returning: ', scopedSelectors + " {" + declarations + "}")
            return scopedSelectors + " {" + declarations + "}";
          }
        );
      }

      function scopeCSSSkipAt(cssText, scope) {
        const lines = cssText.split("\n");
        let output = "";
        let skipMode = false; // when true, we skip lines that start with '@'

        for (let i = 0; i < lines.length; i++) {
          let line = lines[i];
          let trimmed = line.trim();

          // If the line starts with an at‑rule, output it as-is and enter skipMode.
          if (trimmed.startsWith("@")) {
            output += line + "\n";
            skipMode = true;
            continue;
          }

          // If we're in skipMode, we want to look for a line that contains a "{"
          // and does NOT start with "@". That indicates the beginning of a "normal" rule.
          if (skipMode) {
            if (line.indexOf("{") !== -1 && !trimmed.startsWith("@")) {
              // We found a selector line after at‑rules—process its selector.
              let idx = line.indexOf("{");
              let selectors = line.substring(0, idx).trim();
              if (!selectors.startsWith(scope)) {
                selectors = scope + " " + selectors;
              }
              output += selectors + " {" + line.substring(idx + 1) + "\n";
              skipMode = false;
            } else {
              // If the line doesn't contain a "{" (or it still starts with "@"), just output it.
              output += line + "\n";
            }
          } else {
            // If not in skipMode and the line doesn't start with "@",
            // process it as usual.
            if (line.indexOf("{") !== -1) {
              let idx = line.indexOf("{");
              let selectors = line.substring(0, idx).trim();
              if (!selectors.startsWith(scope)) {
                selectors = scope + " " + selectors;
              }
              output += selectors + " {" + line.substring(idx + 1) + "\n";
            } else {
              output += line + "\n";
            }
          }
        }
        return output;
      }

      function scopeCSS(cssText, scope) {
        // Use the 'm' (multiline) flag so the regex works line‐by‐line
        const cssRuleRegex = /([^{}]+?)\s*\{([^{}]*?)\}/gm;
        return cssText.replace(
          cssRuleRegex,
          (match, selectors, declarations) => {
            const scopedSelectors = selectors
              .split(",")
              .map((sel) => {
                let trimmed = sel.trim();
                // If the selector starts with "@" (an at‑rule) or already starts with our scope, skip scoping.
                if (
                  trimmed.startsWith("@") ||
                  trimmed.startsWith(scope) ||
                  /^[\d\.%]+$/.test(trimmed)
                ) {
                  return trimmed;
                }
                return scope + " " + trimmed;
              })
              .join(", ");
            return scopedSelectors + " {" + declarations + "}";
          }
        );
      }

      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,
        highlight: {
          highlightOnLoad: false,
        },
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [
          External,
          RevealMarkdown,
          RevealHighlight,
          RevealNotes,
          Editor,
        ],
      });

      Reveal.on("slidechanged", (event) => {
        if (event.currentSlide.dataset.execute) {
          let result = eval(event.currentSlide.dataset.execute);
          let $result = event.currentSlide.querySelector("p.result");
          $result.innerHTML = result;
        }
      });

      Reveal.on("ready", () => {
        const slideContainers = document.querySelectorAll(".slide-container");

        slideContainers.forEach((container, index) => {
          if (!container.id) {
            container.id = "slide-container-" + (index + 1);
          }
          const containerScope = `#${container.id}`;
          console.log("containerScope", container.parentNode);
          const codeBlock = container.querySelector(".code-block");
          const hiddenCodeBlock = container.querySelector(".hidden-code-block");
          const dataEditDiv = container.querySelector("[data-edit]");

          if (codeBlock && dataEditDiv) {
            codeBlock.dataset.rawContent = codeBlock.innerText;

            const updateDataEdit = () => {
              const visibleContent =
                codeBlock.dataset.rawContent || codeBlock.innerText;
              const hiddenContent = hiddenCodeBlock
                ? hiddenCodeBlock.textContent
                : "";

              let combinedContent = hiddenContent + "\n" + visibleContent;

              combinedContent = combinedContent.replace(
                /<style>([\s\S]*?)<\/style>/gi,
                (match, cssContent) => {
                  const { rootBlock, cssWithoutRoot } =
                    extractRootBlock(cssContent);
                  const processedNonRoot = scopeCSSSkipAt(
                    cssWithoutRoot,
                    containerScope
                  );

                  const processedRoot = rootBlock
                    ? wrapRootInScope(rootBlock, containerScope)
                    : "";

                  return `<style>${processedRoot}${processedNonRoot}</style>`;
                }
              );

              dataEditDiv.innerHTML = combinedContent;
              runInjectedScripts(container.parentNode);
            };

            updateDataEdit();

            const highlight = Reveal.getPlugin("highlight");
            highlight.highlightBlock(codeBlock);

            codeBlock.addEventListener("input", () => {
              codeBlock.dataset.rawContent = codeBlock.innerText;
              updateDataEdit();
            });
          }
        });

        function getCaretCharacterOffsetWithin(element) {
          const selection = window.getSelection();
          let caretOffset = 0;
          if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(range.startContainer, range.startOffset);
            caretOffset = preCaretRange.toString().length;
          }
          return caretOffset;
        }

        function setCaretAtCharacterOffset(element, offset) {
          const selection = window.getSelection();
          const range = document.createRange();
          let charCount = 0,
            found = false;

          function traverseNodes(node) {
            if (node.nodeType === Node.TEXT_NODE) {
              const nextCharCount = charCount + node.length;
              if (!found && offset >= charCount && offset <= nextCharCount) {
                range.setStart(node, offset - charCount);
                range.collapse(true);
                found = true;
              }
              charCount = nextCharCount;
            } else {
              for (let i = 0; i < node.childNodes.length; i++) {
                traverseNodes(node.childNodes[i]);
                if (found) break;
              }
            }
          }
          traverseNodes(element);
          selection.removeAllRanges();
          selection.addRange(range);
        }

        function runInjectedScripts(container) {
          console.log("container: ", container);
          const scripts = container.querySelectorAll("script");

          console.log("scripts: ", scripts);
          scripts.forEach((oldScript) => {
            const newScript = document.createElement("script");
            // Copy attributes from the old script (like type, src, etc.)
            Array.from(oldScript.attributes).forEach((attr) => {
              newScript.setAttribute(attr.name, attr.value);
            });
            newScript.textContent = oldScript.textContent;
            oldScript.parentNode.replaceChild(newScript, oldScript);
          });
        }
      });
    </script>
  </body>
</html>
